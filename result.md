why is result not always zero?
The final result is not always zero because the program contains a race condition. Both the incrementing and decrementing threads (or goroutines) are modifying the shared variable "i" at the same time without synchronization. Since increment (i++) and decrement (i--) are not atomic operations, they can interfere with each other during execution. 
For example, two threads might read the same value of i at the same time, both modify it --> one thread 10 to 11, the other 10 to 9, both accessing the variable at the same time and only the last of these two operations result is returned, and now we have essensially lost one operation. This leads to an unpredictable final value of i.

Now to actualyt fix this and get a consistent results (exactly zero), we would need to synchronize access to i, for example using mutexes in C or sync primitives like sync.Mutex in Go.